<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>常见排序算法 | Simonla&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="常见排序算法横测😂主要选手有

冒泡排序
选择排序
插入排序
希尔排序
归并排序
快速排序

为了比较各种选手的实力，特别增加了他们的爸爸，也就是Sort基类，封装了一些常用的操作，方便我们进行比较
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354">
<meta property="og:type" content="article">
<meta property="og:title" content="常见排序算法">
<meta property="og:url" content="http://yoursite.com/2016/12/03/排序算法/index.html">
<meta property="og:site_name" content="Simonla's Blog">
<meta property="og:description" content="常见排序算法横测😂主要选手有

冒泡排序
选择排序
插入排序
希尔排序
归并排序
快速排序

为了比较各种选手的实力，特别增加了他们的爸爸，也就是Sort基类，封装了一些常用的操作，方便我们进行比较
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/1.png?t=1480593037583">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/2.png?t=1480593037592">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/3.png?t=1480593037585">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/4.png?t=1480593037583">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/5.png?t=1480593037573">
<meta property="og:image" content="http://bihu-face.image.alimmdn.com/6.png?t=1480594935209">
<meta property="og:updated_time" content="2016-12-04T05:09:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常见排序算法">
<meta name="twitter:description" content="常见排序算法横测😂主要选手有

冒泡排序
选择排序
插入排序
希尔排序
归并排序
快速排序

为了比较各种选手的实力，特别增加了他们的爸爸，也就是Sort基类，封装了一些常用的操作，方便我们进行比较
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354">
<meta name="twitter:image" content="http://bihu-face.image.alimmdn.com/1.png?t=1480593037583">
  
    <link rel="alternate" href="/atom.xml" title="Simonla&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Simonla&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">艺术与生活</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/03/排序算法/" class="article-date">
  <time datetime="2016-12-03T05:08:00.000Z" itemprop="datePublished">2016-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithms/">Algorithms</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      常见排序算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常见排序算法横测😂"><a href="#常见排序算法横测😂" class="headerlink" title="常见排序算法横测😂"></a>常见排序算法横测😂</h2><p>主要选手有</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<p>为了比较各种选手的实力，特别增加了他们的爸爸，也就是Sort基类，封装了一些常用的操作，方便我们进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</div><div class="line">    Integer[] mInts;</div><div class="line">    <span class="keyword">int</span> mLen;</div><div class="line"></div><div class="line">    Sort(Integer[] ints) &#123;</div><div class="line">        mInts = ints;</div><div class="line">        mLen = mInts.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回数组</div><div class="line">     * <span class="doctag">@return</span> 数组</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> Integer[] getInts() &#123;</div><div class="line">        <span class="keyword">return</span> mInts;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">sort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 打印出排序后的数组</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSort</span><span class="params">()</span> </span>&#123;</div><div class="line">        sort();</div><div class="line">        <span class="keyword">for</span> (Integer i : mInts) &#123;</div><div class="line">            System.out.println(<span class="keyword">this</span>.getClass().getName() + <span class="string">" ==&gt; "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 按秩交换原数组的两个元素</div><div class="line">     * <span class="doctag">@param</span> i 第一个待交换元素的秩</div><div class="line">     * <span class="doctag">@param</span> j 第二个待交换元素的秩</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        Integer t = mInts[i];</div><div class="line">        mInts[i] = mInts[j];</div><div class="line">        mInts[j] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前一个元素是否小于后一个元素</div><div class="line">     * <span class="doctag">@param</span> i 前一个元素</div><div class="line">     * <span class="doctag">@param</span> j 后一个元素</div><div class="line">     * <span class="doctag">@return</span> 真为小于</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Integer i, Integer j)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span>  i.compareTo(j)&lt;<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 可以优化到 O(logN)</div><div class="line">     * 以输入为界桩，向后找到最小的元素</div><div class="line">     * <span class="doctag">@param</span> i 界桩的秩</div><div class="line">     * <span class="doctag">@return</span> 返回最小元素的秩</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; mLen; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (less(j, min)) min = j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> min;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 搜索特定元素的</div><div class="line">     * <span class="doctag">@param</span> lo 左界桩的秩</div><div class="line">     * <span class="doctag">@param</span> hi 右界桩的秩</div><div class="line">     * <span class="doctag">@param</span> target 待寻找元素的秩</div><div class="line">     * <span class="doctag">@return</span> 如果命中，返回靶的秩，如果没有，返回右界桩的秩</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (mInts[i] &gt; target) <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> hi;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单的检查是否已经排序</div><div class="line">     * <span class="doctag">@return</span> 是否有序</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</div><div class="line">        sort();</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (mLen != mInts.length) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (less(mInts[i + <span class="number">1</span>], mInts[i])) &#123;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                System.out.println(<span class="keyword">this</span>.getClass().getName() + <span class="string">" "</span> + mInts[i] + <span class="string">" - "</span> + mInts[i + <span class="number">1</span>] + <span class="string">" = "</span> + ((mInts[i]) - (mInts[i + <span class="number">1</span>])));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 置乱器，增大元素的混乱程度</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unSort</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mLen ; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">            swap(i - <span class="number">1</span>, <span class="keyword">new</span> Random().nextInt(mLen) % i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 指定范围内向后移动一个单位</div><div class="line">     * <span class="doctag">@param</span> lo 左边界，闭区间</div><div class="line">     * <span class="doctag">@param</span> hi 右边界，闭区间</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveOneStep</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">        System.arraycopy(mInts, lo, mInts, lo + <span class="number">1</span>, hi + <span class="number">1</span> - lo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>因为有些排序算法是输入敏感类型，为了测试算法的稳定性等，特别添加以下功能</p>
<ul>
<li>生成均匀分布的随机数组</li>
<li>生成顺序排布的随机数组</li>
<li>生成元素重复的数组</li>
<li>按线程分别排序，性能优劣一目了然</li>
<li>自动检测排序结果的正确性</li>
<li>算出各种排序算法相对基准时间的比值</li>
<li>因为有些算法实在是太慢，所以分为低分段和高分段分别测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEST_SCALE = <span class="number">1000000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_THREAD = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_DEFAULT = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_CHECK = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_FAST_GROUP = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] mInts = <span class="keyword">new</span> Integer[TEST_SCALE];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        mInts = getRandomArr();</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; doTest(MODE_FAST_GROUP)).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">        BubbleSort bubbleSort = <span class="keyword">new</span> BubbleSort(mInts);</div><div class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort(mInts);</div><div class="line">        SelectionSort selectionSort = <span class="keyword">new</span> SelectionSort(mInts);</div><div class="line">        InsertionSort insertionSort = <span class="keyword">new</span> InsertionSort(mInts);</div><div class="line">        ShellSort shellSort = <span class="keyword">new</span> ShellSort(mInts);</div><div class="line">        QuickSort quickSort = <span class="keyword">new</span> QuickSort(mInts);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (mode) &#123;</div><div class="line">            <span class="keyword">case</span> MODE_CHECK:</div><div class="line">                System.out.println(bubbleSort.getClass().getName() + <span class="string">" ==&gt; "</span> + bubbleSort.check());</div><div class="line">                System.out.println(mergeSort.getClass().getName() + <span class="string">" ==&gt; "</span> + mergeSort.check());</div><div class="line">                System.out.println(selectionSort.getClass().getName() + <span class="string">" ==&gt; "</span> + selectionSort.check());</div><div class="line">                System.out.println(insertionSort.getClass().getName() + <span class="string">" ==&gt; "</span> + insertionSort.check());</div><div class="line">                System.out.println(shellSort.getClass().getName() + <span class="string">" ==&gt; "</span> + shellSort.check());</div><div class="line">                System.out.println(quickSort.check());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MODE_THREAD:</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(bubbleSort)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(mergeSort)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(selectionSort)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(insertionSort)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(shellSort)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printTime(quickSort)).start();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MODE_DEFAULT:</div><div class="line">                <span class="keyword">long</span> bubbleSortTime = bubbleSort.sort();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printMultiple(mergeSort, bubbleSortTime)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printMultiple(insertionSort, bubbleSortTime)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printMultiple(selectionSort, bubbleSortTime)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printMultiple(shellSort, bubbleSortTime)).start();</div><div class="line">                <span class="keyword">new</span> Thread(() -&gt; printMultiple(quickSort, bubbleSortTime)).start();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MODE_FAST_GROUP:</div><div class="line">                printTime(quickSort);</div><div class="line">                printTime(mergeSort);</div><div class="line">                printTime(shellSort);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTime</span><span class="params">(Sort sort)</span> </span>&#123;</div><div class="line">        System.out.println(sort.getClass().getName() + <span class="string">" ==&gt; "</span> + sort.sort() + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMultiple</span><span class="params">(Sort sort, <span class="keyword">long</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> comp = sort.sort();</div><div class="line">        <span class="keyword">if</span> (comp == <span class="number">0</span>) &#123;</div><div class="line">            System.out.println(sort.getClass().getName() + <span class="string">" is too fast"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> multiple = index / comp;</div><div class="line">        System.out.println(sort.getClass().getName() + <span class="string">" "</span> + multiple + <span class="string">"X faster than bubble"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] getRandomArr() &#123;</div><div class="line">        Integer[] arr = <span class="keyword">new</span> Integer[TEST_SCALE];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TEST_SCALE; arr[i++] = <span class="keyword">new</span> Random().nextInt()) ;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] getSortedArr() &#123;</div><div class="line">        Integer[] arr = <span class="keyword">new</span> Integer[TEST_SCALE];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TEST_SCALE; arr[i++] = i) ;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] getRepetitiveArr() &#123;</div><div class="line">        Integer[] arr = <span class="keyword">new</span> Integer[TEST_SCALE];</div><div class="line">        <span class="keyword">int</span> a = <span class="keyword">new</span> Random().nextInt();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TEST_SCALE; i++) &#123;</div><div class="line">            arr[i] = a;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="冒泡排序和选择排序"><a href="#冒泡排序和选择排序" class="headerlink" title="冒泡排序和选择排序"></a>冒泡排序和选择排序</h2><p>这俩没啥好说的，是所有选手里面最慢的，先以10000个随机分布的数组，跑个分试试</p>
<p><img src="http://bihu-face.image.alimmdn.com/1.png?t=1480593037583" alt="图一"></p>
<p>嗨呀好气啊，理论上应该和冒泡排序差不多，为什么选择排序比冒泡排序还慢？</p>
<p>在这里大可不必怀疑我们的结果，好在误差还是在常系数范围内，并且都通过了我们的check功能的检测</p>
<p>很自然的，我们就会去想，这俩货有什么差别？</p>
<p><strong>选择排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen; i++) &#123;</div><div class="line">	<span class="comment">//Sort基类封装了 swap 和 min 操作</span></div><div class="line">	swap(i, min(i)); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>冒泡排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - <span class="number">1</span>; i++) &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mLen - <span class="number">1</span> - i; j++) &#123;</div><div class="line">	<span class="comment">//Sort基类封装了 less 操作</span></div><div class="line">    <span class="keyword">if</span> (less(mInts[j + <span class="number">1</span>], mInts[j]))</div><div class="line">    swap(j, j + <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，他们都是O(n^2)，但是选择排序的交换操作会比冒泡少，而且选择排序是就地算法，不需要额外辅助空间，这大概是它唯二的两个优点了吧</p>
<p>至于之前我们的疑问：<strong><em>我们知道，交换操作消耗的时间比比较消耗的时间更多，为什么选择排序的时间会比冒泡还长？</em></strong></p>
<p>答案是，<strong><em>交换操作消耗的时间比比较消耗的时间更多这个常识</em></strong>，在java上本身就是错的，<strong>因为Java中只是改变了引用位置，而实际对象的位置并没有发生改变</strong>，这点和C/C++不一样！</p>
<h2 id="插入排序和希尔排序"><a href="#插入排序和希尔排序" class="headerlink" title="插入排序和希尔排序"></a>插入排序和希尔排序</h2><p>希尔排序是插入排序的改进版本，而且很神奇的是，一点小小的改进，竟然速度有了如此巨大的提升</p>
<p><img src="http://bihu-face.image.alimmdn.com/2.png?t=1480593037592" alt="图二 基于100000次均匀排布随机数组"></p>
<p>相比冒泡和选择在常系数上的差别，插入和希尔发生了阶上的改变</p>
<p>因为插入排序只会亦步亦趋的去交换相邻的元素，而希尔排序，会一次性将待排元素移动一大步</p>
<p><strong>插入排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mLen; i++) &#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(mInts[j], mInts[j-<span class="number">1</span>]); j--)&#123;</div><div class="line">		swap(j, j-<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">**改进后的插入排序**</div><div class="line"></div><div class="line">```<span class="function">java</span></div><div class="line"><span class="title">for</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mLen; i++)</span> &#123;</div><div class="line">	<span class="keyword">if</span>(less(mInts[i-<span class="number">1</span>],mInts[i])) <span class="keyword">continue</span>;</div><div class="line">	<span class="keyword">int</span> target = mInts[i];</div><div class="line">	<span class="comment">//基类中的search和moveOneStep操作</span></div><div class="line">	<span class="keyword">int</span> result = search(<span class="number">0</span>, i-<span class="number">1</span>, target);</div><div class="line">	moveOneStep(result, i-<span class="number">1</span>);</div><div class="line">    mInts[result] = target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://bihu-face.image.alimmdn.com/3.png?t=1480593037585" alt="图三，100000，改进前"><br><img src="http://bihu-face.image.alimmdn.com/4.png?t=1480593037583" alt="图四，100000，改进后"></p>
<p>改进后，我们在内循环中，将较大的元素都向后移动一位，而不是去交换他们，这样讲数组的访问次数就减半了，这和我们实际的测试数据也相当吻合</p>
<p>可以看到，虽然只是常系数的改变，但是对我们来说这已经足够欣慰，必经我们的代码并没有增加太多，但是更令人欣慰的是希尔排序☺️</p>
<p><strong>希尔排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//步长h</span></div><div class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (h &lt; mLen / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; mLen; i++)  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(mInts[j], mInts[j - h]); j -= h)</div><div class="line">                swap(j, j - h);</div><div class="line">        h = h / <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得一提的是，希尔排序的具体运行速度，取决于我们选择的递减数列，也就是影响了我们上诉代码中的步长h，有兴趣的话，你可以换成不同的递减数列，来比较他们的性能</p>
<p><strong>输入敏感</strong></p>
<p>这俩货都是输入敏感的算法，换句话说，如果输入的数组本身就具有相当的局部有序性，他们都能够立即发现，速度大幅提高</p>
<p><img src="http://bihu-face.image.alimmdn.com/5.png?t=1480593037573" alt="基于10000次顺序数组"></p>
<p>连快排也被斩落马下😂</p>
<h2 id="归并排序和快速排序"><a href="#归并排序和快速排序" class="headerlink" title="归并排序和快速排序"></a>归并排序和快速排序</h2><p>这俩货都是把分治用到极致的算法，直接上代码</p>
<p><strong>归并排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="comment">//到达递归基，不能再分了</span></div><div class="line">    <span class="keyword">if</span> (hi == lo) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</div><div class="line">    mergeSort(lo, mi);</div><div class="line">    mergeSort(mi + <span class="number">1</span>, hi);</div><div class="line">    <span class="comment">//对已经有序的数组，讲时间优化到常数级别，</span></div><div class="line">    <span class="comment">//而且，测试发现，对均匀分布的随机数来说，性能也有能够优化常系数(因为输入敏感，可能对稳定性有影响）</span></div><div class="line">    <span class="keyword">if</span> (mInts[mi] &lt;= mInts[mi + <span class="number">1</span>]) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//对小数组用插入排序计算来进行优化</span></div><div class="line">    <span class="keyword">if</span> (hi - lo &lt; mLen / <span class="number">50</span>) &#123;</div><div class="line">        insertionSort(lo, hi);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        merge(lo, mi, hi);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (less(mInts[i - <span class="number">1</span>], mInts[i])) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> target = mInts[i];</div><div class="line">        <span class="keyword">int</span> result = search(lo, i - <span class="number">1</span>, target);</div><div class="line">        moveOneStep(result, i - <span class="number">1</span>);</div><div class="line">        mInts[result] = target;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="comment">//mInts = B + C,即左半边 + 右半边</span></div><div class="line">    <span class="keyword">int</span> B = lo, C = mi + <span class="number">1</span>;</div><div class="line">    System.arraycopy(mInts, lo, aux, lo, hi + <span class="number">1</span> - lo);</div><div class="line">    <span class="comment">//无论如何，只会执行hi-lo+1次</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">        <span class="comment">//如果左半边用尽，就取右半边的过来</span></div><div class="line">        <span class="keyword">if</span> (B &gt; mi) mInts[k] = aux[C++];</div><div class="line">            <span class="comment">//如果右半边用尽，就取左半边的过来</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (C &gt; hi) mInts[k] = aux[B++];</div><div class="line">            <span class="comment">//两边都没用尽，哪边边小就取过来</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[C], aux[B])) mInts[k] = aux[C++];</div><div class="line">        <span class="keyword">else</span> mInts[k] = aux[B++];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="comment">//递归基，并且对小数组做了优化，感觉不到10%左右的improve</span></div><div class="line">     <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//if (hi - lo &lt;= 6) &#123;</span></div><div class="line">    <span class="comment">//    insertionSort(lo, hi);</span></div><div class="line">    <span class="comment">//    return;</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    <span class="keyword">int</span> j = partition(lo, hi);</div><div class="line">    <span class="comment">//划分后递归调用左右两个子序</span></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> 2016/11/29 可以发现，这里是尾递归，尝试使用迭代法(不知道编译器是否已经对尾递归做了优化)</span></div><div class="line">    quickSort(lo, j - <span class="number">1</span>);</div><div class="line">    quickSort(j + <span class="number">1</span>, hi);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> 2016/11/29 快速三向切分</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="comment">//两个指针，一个从lo开始，一个从hi开始做线性扫描</span></div><div class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</div><div class="line">    <span class="comment">//划分的界桩，未做任何优化</span></div><div class="line">    Integer v = mInts[lo];</div><div class="line">    <span class="comment">//做三取样切分优化，取3为采样率，反而退化了,可能是因为数据已经很均匀了</span></div><div class="line">    <span class="comment">//Integer v = selectMid(lo, hi, 3);</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (less(mInts[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">while</span> (less(v, mInts[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</div><div class="line">        swap(i, j);</div><div class="line">    &#125;</div><div class="line">    swap(lo, j);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">selectMid</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> scale)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> v = mInts[lo];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi &amp;&amp; i - lo &lt;= scale / <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (less(mInts[i + <span class="number">1</span>], mInts[i])) v = mInts[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (less(mInts[i - <span class="number">1</span>], mInts[i])) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> target = mInts[i];</div><div class="line">        <span class="keyword">int</span> result = search(lo, i - <span class="number">1</span>, target);</div><div class="line">        moveOneStep(result, i - <span class="number">1</span>);</div><div class="line">        mInts[result] = target;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，入口都是类似的递归调用<br>而且对于小数组，都用插入排序进行了优化，实测能够有20%左右的提升</p>
<p>不同在于，归并排序是简单的选择了中点来分割，而快排很有趣，是用一种划分的方法</p>
<p>如果划分的不是恰好在数组的中间，而是两侧，就会大幅降低性能，极端情况会多N次的比较<br>，所以我们采样的方法，就是一次取多个采样点，计算中位数，来提高速度(经过测试，根本没有提高！！！，原因不明。。。数学不好。。。数学好的小伙伴可以仔细想一下)</p>
<p>相比插入排序，快排也是输入敏感的，对于已经排好的数组，插入会变得更快，而快排呢，恰恰相反，速度会大幅退化，所以我们更倾向于对快排输入的数组进行一次置乱，置乱器已经集成在了基类里</p>
<p>快排还有很多有趣的东西，我还没有完全弄清楚，就不在这里献丑了😔😔😔</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><img src="http://bihu-face.image.alimmdn.com/6.png?t=1480594935209" alt="数据"></p>
<p>可以看见，到了数据足够大的时候，插入冒泡选择太慢了，慢到没法测试</p>
<p>在这里我们的快排并未进行任何优化，所以比归并慢一些</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">是否稳定</th>
<th style="text-align:left">是否为原地排序</th>
<th style="text-align:left">时间复杂度</th>
<th style="text-align:left">空间复杂度</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">N^2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">最简单的排序</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">N^2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">与冒泡相比减少了交换次数</td>
</tr>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left">N~N^2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">输入敏感</td>
</tr>
<tr>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">取决于递减序列</td>
<td style="text-align:left">1</td>
<td style="text-align:left">输入敏感</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">NlogN</td>
<td style="text-align:left">lgN</td>
<td style="text-align:left">效率由概率提供保障</td>
</tr>
<tr>
<td style="text-align:left">三向快速排序</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">N~NlogN</td>
<td style="text-align:left">lgN</td>
<td style="text-align:left">与输入元素的分布情况有关</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
<td style="text-align:left">NlogN</td>
<td style="text-align:left">N</td>
<td style="text-align:left">可用插入排序对小数组进行优化</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/03/排序算法/" data-id="cixbn7nnq00037s9xgz4kyyjx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/30/View总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          View滑动相关总结
        
      </div>
    </a>
  
  
    <a href="/2016/10/10/列表滚动自动隐藏无关元素/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Toolbar等自动隐藏</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithms/">Algorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/30/View总结/">View滑动相关总结</a>
          </li>
        
          <li>
            <a href="/2016/12/03/排序算法/">常见排序算法</a>
          </li>
        
          <li>
            <a href="/2016/10/10/列表滚动自动隐藏无关元素/">Toolbar等自动隐藏</a>
          </li>
        
          <li>
            <a href="/2016/09/15/萌新指南/">Android 萌新指南</a>
          </li>
        
          <li>
            <a href="/2016/09/12/第一篇博文/">第一篇博文</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Simonla<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>